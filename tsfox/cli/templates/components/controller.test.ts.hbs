// {{testClassName}} - Generated by Fox Framework CLI
// Created on: {{currentDate}}

import request from 'supertest';
import { Express } from 'express';
import { {{className}} } from '../{{kebabName}}.controller';

describe('{{className}}', () => {
  let app: Express;
  let {{name}}Controller: {{className}};

  beforeEach(() => {
    {{name}}Controller = new {{className}}();
    
    // Create mock Express app for testing
    const express = require('express');
    app = express();
    app.use(express.json());
    app.use('/{{kebabName}}', {{name}}Controller.router);
  });

  {{#if withCrud}}
  describe('GET /{{kebabName}}', () => {
    it('should return all {{name}} records', async () => {
      const response = await request(app)
        .get('/{{kebabName}}')
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data).toBeDefined();
      expect(response.body.pagination).toBeDefined();
    });

    it('should handle pagination parameters', async () => {
      const response = await request(app)
        .get('/{{kebabName}}?page=2&limit=5')
        .expect(200);

      expect(response.body.pagination.page).toBe(2);
      expect(response.body.pagination.limit).toBe(5);
    });
  });

  describe('GET /{{kebabName}}/:id', () => {
    it('should return {{name}} by id', async () => {
      const id = '1';
      
      const response = await request(app)
        .get(`/{{kebabName}}/${id}`)
        .expect(200);

      // Note: This will return 404 in current implementation
      // Update when database layer is implemented
    });

    it('should return 404 for non-existent {{name}}', async () => {
      const id = 'non-existent';
      
      await request(app)
        .get(`/{{kebabName}}/${id}`)
        .expect(404);
    });
  });

  describe('POST /{{kebabName}}', () => {
    it('should create new {{name}}', async () => {
      const {{name}}Data = {
        // TODO: Add sample {{name}} data
        name: 'Test {{pascalName}}',
        description: 'Test description'
      };

      const response = await request(app)
        .post('/{{kebabName}}')
        .send({{name}}Data)
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data).toBeDefined();
      expect(response.body.message).toContain('created successfully');
    });

    it('should validate required fields', async () => {
      const invalidData = {};

      const response = await request(app)
        .post('/{{kebabName}}')
        .send(invalidData);

      // Validation will be added with validation middleware
      // For now, it should still create the record
      expect([200, 201, 400]).toContain(response.status);
    });
  });

  describe('PUT /{{kebabName}}/:id', () => {
    it('should update existing {{name}}', async () => {
      const id = '1';
      const updateData = {
        name: 'Updated {{pascalName}}',
        description: 'Updated description'
      };

      const response = await request(app)
        .put(`/{{kebabName}}/${id}`)
        .send(updateData)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data).toBeDefined();
      expect(response.body.message).toContain('updated successfully');
    });

    it('should return 404 for non-existent {{name}}', async () => {
      const id = 'non-existent';
      const updateData = { name: 'Updated' };

      await request(app)
        .put(`/{{kebabName}}/${id}`)
        .send(updateData)
        .expect(404);
    });
  });

  describe('DELETE /{{kebabName}}/:id', () => {
    it('should delete existing {{name}}', async () => {
      const id = '1';

      const response = await request(app)
        .delete(`/{{kebabName}}/${id}`)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.message).toContain('deleted successfully');
    });

    it('should return 404 for non-existent {{name}}', async () => {
      const id = 'non-existent';

      await request(app)
        .delete(`/{{kebabName}}/${id}`)
        .expect(404);
    });
  });
  {{else}}
  describe('GET /{{kebabName}}', () => {
    it('should return success message', async () => {
      const response = await request(app)
        .get('/{{kebabName}}')
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.message).toContain('{{pascalName}} controller is working');
      expect(response.body.timestamp).toBeDefined();
    });
  });
  {{/if}}

  describe('Error Handling', () => {
    it('should handle internal server errors gracefully', async () => {
      // Mock a service method to throw an error
      {{#if service}}
      jest.spyOn({{name}}Controller['{{name}}Service'], 'findAll')
        .mockRejectedValueOnce(new Error('Database error'));
      {{/if}}

      const response = await request(app)
        .get('/{{kebabName}}');

      // Error handling will depend on global error middleware
      expect([500, 200]).toContain(response.status);
    });
  });

  describe('Router Configuration', () => {
    it('should have router property', () => {
      expect({{name}}Controller.router).toBeDefined();
    });

    it('should configure routes properly', () => {
      const routes = {{name}}Controller.router.stack;
      expect(routes.length).toBeGreaterThan(0);
    });
  });
});
